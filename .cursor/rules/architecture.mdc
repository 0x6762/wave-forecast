# Architecture

## Project Structure
```
lib/
├── models/       # Data models (SurfConditions, TideData, etc.)
├── repositories/ # API integration (abstract interfaces + implementations)
├── database/     # Drift caching layer
└── main.dart     # UI + dependency injection
```

## Separation of Concerns
- **Models**: Pure data classes, no business logic
- **Repositories**: API integration via abstract interfaces (easy provider swapping)
- **Database**: Generic caching layer (Drift), extensible for multiple data types
- **UI**: Presentation logic only, consumes repositories via Provider

## Repository Pattern
```dart
// 1. Define interface
abstract class DataRepository { Future<Data> getData({...}); }

// 2. Implement for specific provider
class ProviderRepository implements DataRepository { /* API calls */ }

// 3. Swap easily in main.dart
Provider<DataRepository>(create: (_) => ProviderRepository())
```

**Current**: `WeatherRepository` (Open-Meteo), `TideDataRepository` (Stormglass)

## Dependency Injection
- Use Provider for DI (see main.dart)
- Pass repositories via constructors
- Keep dependencies explicit and mockable

## Best Practices
- Repository pattern for all external data
- Generic database schema for extensibility
- Smart caching (proximity-based, expiring)
- Parallel data fetching (weather + tide)
- Graceful degradation (null = unavailable)
